# Plan: Add Prebuilt Provider Routing (Revision 3)

**Goal:** Add a new endpoint `/provider/{provider_id}/v1/chat/completions` to the FastAPI application alongside the existing `/proxy/{provider_base_url:path}/v1/chat/completions` endpoint. This new endpoint will provide a consistent URL structure for clients. Internally, it will look up the `provider_id` in a configuration dictionary to find the **full target URL** for that provider (which might be different from `/v1/chat/completions`) and then proxy the request directly to that configured URL.

**Steps:**

1.  **`config.py`:**
    *   No changes needed from Revision 2.
    *   The `PREBUILT_PROVIDERS` dictionary maps provider IDs (strings like `"chutes"`) to their corresponding **full target URLs** (strings like `"https://llm.chutes.ai/v1/chat/completions"` or `"https://api.someprovider.com/custom/path/endpoint"`).
    *   Example:
        ```python
        PREBUILT_PROVIDERS = {
            "chutes": "https://llm.chutes.ai/v1/chat/completions",
            # Add other pre-configured providers with their full URLs here
            "another_provider": "https://api.anotherprovider.com/custom/path"
        }
        ```

2.  **`proxy.py`:**
    *   Import `PREBUILT_PROVIDERS` from `config`.
    *   Modify the existing prebuilt provider endpoint function (e.g., `prebuilt_provider_proxy`).
    *   Change the route decorator for this function back to `@app.post("/provider/{provider_id}/v1/chat/completions")`.
    *   The function will take `provider_id: str`, `request_body: ChatCompletionRequest`, and `raw_request: Request` as parameters. The `provider_id` is captured from the path.
    *   **Inside the function:**
        *   Look up `provider_id` in the `PREBUILT_PROVIDERS` dictionary. The `/v1/chat/completions` part of the incoming route is **ignored** for the lookup and target URL determination.
        *   If the `provider_id` is not found, raise an `HTTPException` with a 404 status code.
        *   If found, the retrieved value **is the full `target_url`**. Use this value directly.
        *   Prepare the necessary headers (like `Content-Type`, `Accept`, and forwarding `Authorization` from `raw_request`), mirroring the logic in the existing `chat_completion` endpoint.
        *   Reuse the existing `stream_generator` function, passing the looked-up `target_url`, `request_body`, and `headers`.
        *   Return the `StreamingResponse` generated by `stream_generator`.
    *   Update OpenAPI documentation (summary, description, tags) for the modified endpoint, clarifying the route structure vs. the internal target URL.

**Visual Plan (Mermaid Diagram):**

```mermaid
graph TD
    A[Client Request: POST /provider/chutes/v1/chat/completions] --> B{FastAPI Router};
    B -- Route Match --> C[prebuilt_provider_proxy Function];
    C -- provider_id='chutes' (from path) --> D{Lookup 'chutes' in PREBUILT_PROVIDERS};
    subgraph config.py
        J[PREBUILT_PROVIDERS = {"chutes": "https://llm.chutes.ai/v1/chat/completions", "other": "https://api.someprovider.com/custom/path"}]
    end
    D -- Found: target_url='https://llm.chutes.ai/v1/chat/completions' --> E[Use Target URL Directly];
    E --> F[Prepare Headers (incl. Auth)];
    F --> G[Call stream_generator(target_url, body, headers)];
    subgraph streaming.py
        K[stream_generator Function]
    end
    G --> K;
    K --> H[Stream Response to Client];

    D -- Not Found --> I[Return 404 Not Found];

    subgraph proxy.py
        B; C; E; F; I;
    end

    C --> J;